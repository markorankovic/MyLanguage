options {
  STATIC = false;
}

PARSER_BEGIN(MyParser)

public class MyParser {

	public static void main(String[] args) {
	  try {
	    MyParser parser = new MyParser( System.in );
	    parser.StatementExpression();
	    System.out.println("Pass");
	  } catch (Throwable e) {
	    System.out.println("Fail");
	  }
	}
  
}

PARSER_END(MyParser)

SKIP: {
    " " | "\t" | "\r" | "\n" 
}

TOKEN: {
  <REQUIRE: "require">
| <IF: "if">
| <WHILE: "while">
| <FOR: "for">
| <FUNC: "func">
}

TOKEN: {
  <STRING: "\"" (~["\"", "\\"] | "\\\"" | "\\\\")* "\"" >
| <#DIGIT: ["0"-"9"]>
| <INTEGER: (["1"-"9"] (["0"-"9"])*) | "0">
| <DEF: "def">
| <#LETTER: ["_","a"-"z","A"-"Z"]>
| <NAME: <LETTER> (<LETTER>|<DIGIT>)*>
| <ASSIGNMENT: "=">
| <RETURNSYMBOL: "->">
}

TOKEN: {
  <ADD: "+">
|   <SUB: "-">
|   <MUL: "*">
|   <DIV: "/">
|	<EQ: "==">
|	<NEQ: "!=">
| <LESS: "<">
| <GREATER: " >">
| <LESSOREQUAL: "<=">
| <GREATEROREQUAL: " >=">
}

TOKEN: {
  <OBRACKET: "(">
| <CBRACKET: ")">
| <OBRACE: "{">
| <CBRACE: "}">
| <SEMICOLON: ";">
}

void Start(): {}{
  (
    Require()
  )+
  (
    StatementExpression()  )*
}

void Assignment(): {}{ <NAME> <ASSIGNMENT> (<STRING> | MathExpression()) }
void VariableDeclaration(): {}{ <DEF> <NAME> <ASSIGNMENT> (<STRING> | <INTEGER>) }

void Add(): {}{ <INTEGER> <ADD> <INTEGER> }
void Sub(): {}{ <INTEGER> <SUB> <INTEGER> }
void MUL(): {}{ <INTEGER> <MUL> <INTEGER> }
void DIV(): {}{ <INTEGER> <DIV> <INTEGER> }
void Equals(): {}{ <INTEGER> <EQ> <INTEGER> }
void MathExpression(): {}{ AddExpression() }
void MultiplyExpression(): {}{ UnaryExpression() ((<MUL> | <DIV>) UnaryExpression())* }
void AddExpression(): {} { MultiplyExpression() <ADD> MultiplyExpression() }
void UnaryExpression(): {} { <OBRACKET> MathExpression() <CBRACKET> | <INTEGER> | <NAME> }
void UnaryRelational(): { } { <INTEGER> | <NAME> }
void RelationalLessExpression() : {} { UnaryRelational() ((<LESS> | <LESSOREQUAL>) UnaryRelational())* }
void RelationalGreaterExpression() : {} { RelationalLessExpression() ((<GREATER> | <GREATEROREQUAL>) RelationalLessExpression())* }
void RelationalEqualityExpression() : {} { RelationalGreaterExpression() (( <EQ> | <NEQ> ) RelationalGreaterExpression())* }
void RelationalExpression() : {} { RelationalEqualityExpression() }

void Require(): {} {
	<REQUIRE> (<NAME>)+
}

void StatementExpression(): {} {
  VariableDeclaration()
| LOOKAHEAD(2) Assignment()
| IfExpression()
| WhileExpression()
| ForExpression()
}

void IfExpression(): {} {
  <IF> RelationalExpression() <OBRACE>
  	(
  	  StatementExpression() 	)*
  <CBRACE>
}

void WhileExpression(): {} {
  <WHILE> RelationalExpression() <OBRACE>
  	(
  	  StatementExpression()
 	)*
  <CBRACE>
}

void ForExpression(): {} {
  <FOR> <OBRACKET> VariableDeclaration() <SEMICOLON> RelationalExpression() <SEMICOLON> Assignment() <CBRACKET> <OBRACE>
  	(
  	  StatementExpression()
 	)*
  <CBRACE>
}

void FuncExpression(): {} {
	<FUNC> <OBRACKET> <CBRACKET> <OBRACE>
		(
  	 		StatementExpression()
 		)*
	<CBRACE>
}























